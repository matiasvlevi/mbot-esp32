import { Dispatch } from "react";
import { TEdge, TNode, VisualNode, TPort } from "./types";

import { EdgeAction, EventStoreAction, NodeAction, StoreAction } from "./reducers/reducers";
import { FormatEvent } from "./events";

export async function fetchNode(
    blueprints: Record<string, VisualNode>,
    nodes: Record<string, TNode>,
    edges: Record<string, TEdge>,
    port: TPort,
    store: Record<string, any>,
    abortController: AbortController
): Promise<Record<string, any>> {
    if (abortController.signal.aborted) return { abort: true };

    const values: Record<string, any> = {};

    // Iterate over all connections
    if (port.edgeIds)
        for (const edgeId of port.edgeIds) {
            const inputEdge = edges[edgeId];

            // Highlight value edge
            inputEdge.highlight = true;

            const inputNode = nodes[inputEdge.from.nodeId || ""];
            const inputPort =
                inputNode.ports.find(
                    (port) => port.id === inputEdge.from.portId
                ) || inputNode.ports[0];

            const bp = blueprints[inputNode.signature];

            const setCache = (value: any) => {
                inputPort.Cache = value;
            };

            // Get all values in previous values
            //
            // If no label is provided for input, use number indeces
            //
            let previousValues: Record<string, any> = {};
            if (inputPort.edgeIds && inputPort.edgeIds.length > 0) {


                for (const port of inputNode.ports) {
                    // Ignore output triggers
                    if (port.role === "output") continue;

                    const newValues = await fetchNode(
                        blueprints,
                        nodes,
                        edges,
                        port,
                        store,
                        abortController
                    );

                    let i = 0;
                    while (
                        previousValues[i] !== undefined &&
                        newValues[i] !== undefined
                    ) {
                        newValues[i + 1] = newValues[i];
                        delete newValues[i];
                        i++;
                    }

                    previousValues = {
                        ...previousValues,
                        ...newValues,
                    };
                }
            }

            // Get port Blueprint
            const portBp = bp.ports[inputPort.signature] || {};

            if (portBp.Fetch) {
                // Add result value
                const ret = portBp.Fetch({
                    node: inputNode,
                    state: inputNode.State,
                    cache: inputPort.Cache,
                    setCache,
                    store,
                    inputs: previousValues,
                });

                if (ret instanceof Promise) {
                    values[inputEdge.from.portId] = await ret;
                } else {
                    values[inputEdge.from.portId] = ret;
                }
            }

            inputEdge.highlight = undefined;
        }

    let globalState: Record<string, any> = {};
    let i = 0;
    for (let portId in values) {
        globalState[port.label || `${i}`] = values[portId];
        i++;
    }

    return globalState;
}

/**
 * 
 * @param blueprints 
 * @param nodes 
 * @param edges 
 * @param node 
 * @param dispatchNode 
 * @param store 
 * @param setStoreItem 
 * @param abortController 
 * @param eventInstance
 * @returns 
 */
export async function execTriggeredNodes(
    blueprints: Record<string, VisualNode>,
    
    nodes: Record<string, TNode>,
    edges: Record<string, TEdge>,

    node: TNode,
    dispatchNode: Dispatch<NodeAction>,
    
    store: Record<string, any>,
    setStoreItem: Dispatch<StoreAction>,
    
    abortController: AbortController,

    eventInstance: any | null
): Promise<boolean> {
    if (abortController.signal.aborted) {
        return true;
    };

    // Find all triggers
    const triggers = node.ports.filter(
        (port) => port.type === "trigger" && port.role === "output"
    );

    // Abort if no connections
    if (triggers.length < 0) return true;

    // Find Input Values
    let previousValues: Record<string, any> = {};
    for (let port of node.ports) {
        if (port.type === "trigger" || port.role === "output") continue;
        
        if (port.edgeIds) for (let edgeId of port.edgeIds) {
            // Get the current node Id
            const edge = edges[edgeId || ""];
            if (!edge) continue;

            // Highlight value edge
            edge.highlight = true;
        }

        previousValues = {
            ...previousValues,
            ...(await fetchNode(blueprints, nodes, edges, port, store, abortController)),
        };
    }

    /**
     * Trigger an output port function
     * 
     * @param portIndex The index of the output port 
     */
    const trigger = async (portIndex: number | string) => {

        let port: TPort | undefined;
        if (typeof portIndex === 'string') {
            port = triggers.find(p => p.label === portIndex || p.id === portIndex);
            // try to find in range
            if (!port) {
                const portRange = triggers.find(p => p.range);

                if (portRange) {
                    port = portRange.range?.ports.find(p => p.label === portIndex || p.id === portIndex);
                }
            }
        } else {
            // Get by trigger port index 
            if (portIndex < 0 || portIndex > triggers.length) return;
            port = triggers[portIndex];
        }

        if (!port) return;
        if (!port.edgeIds) return;

        const triggerPromises: Promise<any>[] = [];

        for (let edgeId of port.edgeIds) {
            // Get the current node Id
            const edge = edges[edgeId || ""];
            if (!edge) continue;

            // Highlight edge
            edge.highlight = true;

            // Wait a frame
            // await new Promise(r => setTimeout(r, 1 || 41.66));

            const id = edge.to.nodeId;
            if (!id) continue;

            // Recurse for next node
            triggerPromises.push(execTriggeredNodes(
                blueprints,
                nodes,
                edges,
                nodes[id],
                dispatchNode,
                store,
                setStoreItem,
                abortController,
                null
            ));
        }

        // Wait for branches to resolve
        const responses = await Promise.all(triggerPromises);

        // 
        port.edgeIds.forEach(edgeId => {
            const edge = edges[edgeId || ""];
            if (!edge) return;

            edge.highlight = undefined;
        });

        return responses;
    };

    /**
     * Update a node in the global node state
     * 
     * @param node The node to update
     * @returns 
     */
    const update = (node: TNode) => {
        return dispatchNode({
            type: "UPDATE_NODE",
            payload: node,
        });
    };

    /**
     * Set a fetch port's cache
     * 
     * @param label The fetch port label
     * @param value The value to set in the fetch port's cache
     * @returns 
     */
    const setCache = (label: string, value: any) => {
        const port = node.ports.find((p) => p.label === label);

        if (!port) return;

        port.Cache = value;
    };

    const bp = blueprints[node.signature];
    
    // Abort if no trigger
    if (!bp.Trigger) return false;

    // If the node is an event, inject the event instance in the port's cache
    if (bp.Name === "Event") {
        const port = node.ports.find((p) => p.label === 'event');
        
        if (port) port.Cache = FormatEvent(eventInstance);
    }

    /**
     * Calling the blueprint's trigger
     */
    const ret = bp.Trigger({
        node,
        inputs: previousValues,
        state: node.State,
        store,
        controller: {
            trigger,
            update,
            setCache,
            setStoreItem,
        },
    });

    if (ret instanceof Promise) {
        await ret;
    };

    return false;
}

export function findEventNodes(
    nodes: Record<string, any>,
    name: string
) {
    const EventNodes = Object.values(nodes)
        .filter(node => node.signature === "Event");
    
    if (!EventNodes) {
        return;
    };

    const EventNode = EventNodes.find(node => node.State.eventName === name);

    if (!EventNode) {
        return;
    };

    return EventNode;
}

export async function exec(
    blueprints: Record<string, VisualNode>,
    nodes: Record<string, TNode>,
    edges: Record<string, TEdge>,
    dispatchEdge: Dispatch<EdgeAction>,
    dispatchNode: Dispatch<NodeAction>,
    store: Record<string, any>,
    eventStore: Record<string, any>,
    setStoreItem: Dispatch<StoreAction>,
    setEventStoreItem: Dispatch<EventStoreAction>,
    abortController: AbortController
): Promise<boolean> {
    if (abortController.signal.aborted) return true;

    // Clear Cache
    Object.values(nodes).forEach((node) => {
        node.ports.forEach((port) => {
            port.Cache = {};
            if (port.edgeIds) port.edgeIds.forEach(edgeId => {
                edges[edgeId].highlight = undefined;
            })
        });
    });

    /**
     * Remove all highlights and clear cache once aborted
     */
    abortController.signal.addEventListener('abort', () => {
        Object.values(nodes).forEach((node) => {
            node.ports.forEach((port) => {
                port.Cache = {};
                if (port.edgeIds) port.edgeIds.forEach(edgeId => {
                    edges[edgeId].highlight = undefined;
                })
            });
        });
    });

    const findEventsAndTrigger = async (name: string, eventInstance: any): Promise<boolean> => {
        const EventNode = findEventNodes(nodes, name);
        const port = EventNode.ports.find((p: any) => p.type === 'trigger' && p.role === 'output');
        if (!port) return new Promise(r => r(true));

        // Remove edge hightlight
        if (port.edgeIds) port.edgeIds.forEach((edgeId: any) => {
            // Get the current node Id
            const edge = edges[edgeId || ""];
            if (!edge) return;

            // Highlight edge
            edge.highlight = true;
        });

        // Wait a tick
        await new Promise(r => setTimeout(r, 1 || 41.66));

        // Trigger event node if found, return promise
        if (EventNode) return execTriggeredNodes(
            blueprints,
            nodes,
            edges,
            EventNode,
            dispatchNode,
            store,
            setStoreItem,
            abortController,
            eventInstance
        );
        // If not found, return empty promise
        else return new Promise(r => r(true));
    }

    const hangIfEventsRunning = (resolve: (data: unknown) => void) => {
        // Filter out basic 'play' event
        const eventsWithoutPlay = 
            Object.values(eventStore)
                  .filter(x => x.id !== 'play');

        // Resolve if no other events than play are found
        if (eventsWithoutPlay.length === 0) {
            resolve({});
        }
    }

    const createEventListener = (name: string) => {
        return function (e: any) { 
            findEventsAndTrigger(name, e);
        }
    }

    /**
     * Play event
     */
    const EventPlay = async (branch: (eventProps: any) => Promise<undefined>): Promise<undefined> => {
        return branch({
            startTime: new Date().getTime()
        });
    }

    /**
     * Loop Event
     */
    const EventLoop = async (branch: (eventProps: any) => Promise<undefined>): Promise<undefined> => {
        let tick = 0;
        let delta = 0;

        do {

            const startTime = new Date().getMilliseconds();
    
            // Run the event trigger
            await branch({ tick, delta });

            // Wait 16.66 ms
            await (new Promise(r => setTimeout(r, 41.66 /* 1/24fps = 41.66 or 1/60fps = 16.66 */ )));

            // Compute time, with branch and delay
            delta = new Date().getMilliseconds() - startTime;
            
            // Increment tick
            tick++;

        } while (!abortController.signal.aborted);
    }

    const events: Record<string, any> = {};

    // Promise that does not resolve on its own
    const pollEvents = new Promise(resolve => {
        const customEventsPromises = Object.entries(eventStore).map(([name, event]) => {

            if (!events[name]) events[name] = {
                id: event.id,
                listener: createEventListener(name)
            };
        
            setEventStoreItem({
                type: 'SET_EVENT',
                name, value: {
                    ...events[name]
                }
            });

            switch(event.id) {
                case 'play': {
                    return EventPlay(async (eventProps) => {
                        findEventsAndTrigger(name, eventProps);
                    });
                }
                case 'loop': {
                    return EventLoop(async (eventProps) => {
                        findEventsAndTrigger(name, eventProps)
                    });
                }
            }

            window.addEventListener(events[name].id, events[name].listener);
            return new Promise(r => r({}));
        });

        Promise.all(customEventsPromises);

        hangIfEventsRunning(resolve);
    })


    Object.values(nodes).forEach(node => {
        node.ports.forEach(port => {
            if (port.edgeIds) port.edgeIds.forEach(edgeId => {
                edges[edgeId].highlight = undefined;
            })
        })
    });

    dispatchEdge({ type: 'SET_EDGES', payload: edges });
    await pollEvents;



    // reset event listeners
    for (let name in events) {
        if (events[name].id !== 'play') {
            window.removeEventListener(events[name].id, events[name].listener);
        }
    }


    return false;
}
