"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exec = exports.findEventNodes = exports.execTriggeredNodes = exports.fetchNode = void 0;
const events_1 = require("./events");
async function fetchNode(blueprints, nodes, edges, port, store, abortController) {
    if (abortController.signal.aborted)
        return { abort: true };
    const values = {};
    console.log('fetch port edge ids', port.edgeIds);
    // Iterate over all connections
    if (port.edgeIds)
        for (const edgeId of port.edgeIds) {
            const inputEdge = edges[edgeId];
            const inputNode = nodes[inputEdge.from.nodeId || ""];
            const inputPort = inputNode.ports.find((port) => port.id === inputEdge.from.portId) || inputNode.ports[0];
            console.log('fetch port ', inputPort);
            const bp = blueprints[inputNode.signature];
            const setCache = (value) => {
                inputPort.Cache = value;
            };
            // Get all values in previous values
            //
            // If no label is provided for input, use number indeces
            //
            let previousValues = {};
            if (inputPort.edgeIds && inputPort.edgeIds.length > 0) {
                for (const port of inputNode.ports) {
                    // Ignore output triggers
                    if (port.role === "output")
                        continue;
                    const newValues = await fetchNode(blueprints, nodes, edges, port, store, abortController);
                    let i = 0;
                    while (previousValues[i] !== undefined &&
                        newValues[i] !== undefined) {
                        newValues[i + 1] = newValues[i];
                        delete newValues[i];
                        i++;
                    }
                    previousValues = {
                        ...previousValues,
                        ...newValues,
                    };
                }
            }
            // Get port Blueprint
            const portBp = bp.ports[inputPort.signature] || {};
            console.log(portBp, bp.ports, inputPort.signature);
            if (portBp.Fetch) {
                // Add result value
                const ret = portBp.Fetch({
                    node: inputNode,
                    state: inputNode.State,
                    cache: inputPort.Cache,
                    setCache,
                    store,
                    inputs: previousValues,
                });
                console.log('FETCH RESPONSE ', ret);
                if (ret instanceof Promise) {
                    values[inputEdge.from.portId] = await ret;
                }
                else {
                    values[inputEdge.from.portId] = ret;
                }
            }
        }
    let globalState = {};
    let i = 0;
    for (let portId in values) {
        globalState[port.label || `${i}`] = values[portId];
        i++;
    }
    return globalState;
}
exports.fetchNode = fetchNode;
/**
 *
 * @param blueprints
 * @param nodes
 * @param edges
 * @param node
 * @param dispatchNode
 * @param store
 * @param setStoreItem
 * @param abortController
 * @param eventInstance
 * @returns
 */
async function execTriggeredNodes(blueprints, nodes, edges, node, dispatchNode, store, setStoreItem, abortController, eventInstance) {
    if (abortController.signal.aborted)
        return true;
    const triggers = node.ports.filter((port) => port.type === "trigger" && port.role === "output");
    // Abort if no connections
    if (triggers.length < 0)
        return true;
    // Find Input Values
    let previousValues = {};
    for (let port of node.ports) {
        if (port.type === "trigger" || port.role === "output")
            continue;
        previousValues = {
            ...previousValues,
            ...(await fetchNode(blueprints, nodes, edges, port, store, abortController)),
        };
    }
    /**
     * Trigger an output port function
     *
     * @param portIndex The index of the output port
     */
    const trigger = async (portIndex) => {
        if (portIndex < 0 || portIndex > triggers.length)
            return;
        const port = triggers[portIndex];
        if (!port)
            return;
        if (!port.edgeIds)
            return;
        const triggerPromises = [];
        for (let edgeId of port.edgeIds) {
            // Get the current node Id
            const edge = edges[edgeId || ""];
            if (!edge)
                continue;
            if (!edge.to)
                continue;
            const id = edge.to.nodeId;
            if (!id)
                continue;
            // Recurse for next node
            triggerPromises.push(execTriggeredNodes(blueprints, nodes, edges, nodes[id], dispatchNode, store, setStoreItem, abortController, null));
        }
        await Promise.all(triggerPromises);
    };
    /**
     * Update a node in the global node state
     *
     * @param node The node to update
     * @returns
     */
    const update = (node) => {
        return dispatchNode({
            type: "UPDATE_NODE",
            payload: node,
        });
    };
    /**
     * Set a fetch port's cache
     *
     * @param label The fetch port label
     * @param value The value to set in the fetch port's cache
     * @returns
     */
    const setCache = (label, value) => {
        const port = node.ports.find((p) => p.label === label);
        if (!port)
            return;
        port.Cache = value;
    };
    const bp = blueprints[node.signature];
    // Abort if no trigger
    if (!bp.Trigger)
        return false;
    // If the node is an event, inject the event instance in the port's cache
    if (bp.Name === "Event") {
        const port = node.ports.find((p) => p.label === 'event');
        if (port)
            port.Cache = (0, events_1.FormatEvent)(eventInstance);
    }
    /**
     * Calling the blueprint's trigger
     */
    const ret = bp.Trigger({
        node,
        inputs: previousValues,
        state: node.State,
        store,
        controller: {
            trigger,
            update,
            setCache,
            setStoreItem,
        },
    });
    if (ret instanceof Promise)
        await ret;
    return false;
}
exports.execTriggeredNodes = execTriggeredNodes;
function findEventNodes(nodes, name) {
    const EventNodes = Object.values(nodes)
        .filter(node => node.signature === "Event");
    if (!EventNodes) {
        return;
    }
    ;
    const EventNode = EventNodes.find(node => node.State.eventName === name);
    if (!EventNode) {
        return;
    }
    ;
    return EventNode;
}
exports.findEventNodes = findEventNodes;
async function exec(blueprints, nodes, edges, dispatchNode, store, eventStore, setStoreItem, setEventStoreItem, abortController) {
    if (abortController.signal.aborted)
        return true;
    // Clear Cache
    Object.values(nodes).forEach((node) => {
        node.ports.forEach((port) => {
            port.Cache = {};
        });
    });
    const BeginNode = Object.values(nodes).find((node) => node.signature === "Begin");
    if (!BeginNode) {
        // TODO: HANDLE ERROR
        // No Begin Node Found
        console.warn("No Begin Node found");
    }
    const findEventsAndTrigger = async (name, eventInstance) => {
        const EventNode = findEventNodes(nodes, name);
        console.log('FOUND', EventNode);
        // Trigger event
        if (EventNode)
            return execTriggeredNodes(blueprints, nodes, edges, EventNode, dispatchNode, store, setStoreItem, abortController, eventInstance);
        else
            return new Promise(r => r({}));
    };
    const hangIfEventsRunning = (resolve) => {
        // Filter out basic 'play' event
        const eventsWithoutPlay = Object.values(eventStore)
            .filter(x => x.id !== 'play');
        // Resolve if no other events than play are found
        if (eventsWithoutPlay.length === 0) {
            resolve({});
        }
    };
    const createEventListener = (name) => {
        return function (e) {
            findEventsAndTrigger(name, e);
        };
    };
    const events = {};
    // Promise that does not resolve on its own
    const pollEvents = new Promise(resolve => {
        Object.entries(eventStore).forEach(([name, event]) => {
            if (event.id === 'play') {
                findEventsAndTrigger(name, { play: true });
            }
            if (!events[name])
                events[name] = {
                    id: event.id,
                    listener: createEventListener(name)
                };
            setEventStoreItem({
                type: 'SET_EVENT',
                name, value: {
                    ...events[name]
                }
            });
            window.addEventListener(events[name].id, events[name].listener);
        });
        hangIfEventsRunning(resolve);
    });
    await pollEvents;
    // reset event listeners
    for (let name in events) {
        if (events[name].id !== 'play') {
            window.removeEventListener(events[name].id, events[name].listener);
        }
    }
    return false;
}
exports.exec = exec;
