import { Dispatch } from "react";
import { StoreAction } from "./reducers/reducers";
import { TNode, VisualPort } from './types';
/**
 * @group NodeComposition
 */
/**
 * Used to update the state of a node
 *
 * @interface
 */
export interface StateController {
    /**
     * Update the node
     *
     * @param node The new updated node
     */
    update: (node: TNode) => void;
}
/**
 * Used to control everything related to the node,
 * you can modify the cache, the variable store and trigger a particular port
 *
 *
 * @interface
 */
export interface Controller extends StateController {
    /**
     * Trigger an output port (has to be of type trigger)
     *
     * @param outputPortIndex The index of the port to trigger
     *
     * @example
     * ```tsx
     * export function Trigger({ controller }) {
     *   // Do stuff ...
     *
     *   // Call the node connected on our output trigger
     *   return controller.trigger(0);
     * }
     *
     * export ports = [
     *   port.input().type('trigger')
     *   port.output().type('trigger')
     * ]
     * ```
     *
     * Handling multiple output ports is done through the `outputPortIndex` argument, the following example would have two output trigger ports and always trigger the second one.
     *
     * ```tsx
     * export function Trigger({ controller }) {
     *
     *   // Do stuff
     *
     *   // Call the node connected on our output trigger
     *   return controller.trigger(1);
     * }
     *
     * export ports = [
     *   port.input().type('trigger')
     *   port.output().type('trigger'),
     *   port.output().type('trigger')
     * ]
     * ```
     *
     *
     * @tip returning `controller.trigger(0)` in the `Trigger` callback is considered good practice
     */
    trigger: (outputPortIndex: number) => void;
    /**
     * Cache an output port value.
     *
     * Allows you to use them in other callbacks or components.
     * Using the provided cache is considered good practice
     *
     * @param label The output port's label
     * @param value The value to assign to the port's cache
     *
     * @tip Useful for asynchronous operations where
     * you don't want to run twice for each Node port onFetch
     *
     * @tip Useful for `nodes` with a random generated value,
     * where you would not want multiple random values from the same fetched Node port
     *
     *
     * @example
     * In the following example we fetch a remote resource `https://example.com/` and setting the response in the cache before triggering the next node.
     *
     * In our `onFetch` port callback, we return the cached page
     *
     * ```tsx
     * export function Trigger({ controller }) {
     *
     *   // Fetch a resource,
     *   fetch('https://example.com')
     *      .then(res => res.text())
     *      .then(html => {
     *          controller.setCache('page', html);
     *          controller.trigger(0);
     *       })
     * }
     *
     * export const ports = [
     *   port.input().type('trigger'),
     *   port.output().type('trigger'),
     *
     *   // We are returning the value we cached in `Trigger` when the port is fetched
     *   port.output().type('string').label('page').onFetch(({ cache }) => cache)
     * ];
     * ```
     */
    setCache: (label: string, value: any) => void;
    /**
     * Set a Global variable
     *
     * @param label The variable's name
     * @param value The variable's type
     *
     * @example
     * ```tsx
     * console.log('Example here');
     * ```
     */
    setStoreItem: Dispatch<StoreAction>;
}
/**
 *
 * Values passed in the Node Content Component
 *
 * @info Passing down the `nodeId` property to your statful components is required
 *
 * @ExportFunctionArgs
 */
export interface ContentProps {
    state: Record<string, any>;
    store: Record<string, any>;
    node: TNode;
    nodeId: string;
    elemId: number;
    controller: StateController;
}
/**
 *
 * Values passed in the Node Trigger Callback
 *
 * @ExportFunctionArgs
 */
export interface TriggerProps {
    /**
     * The Node instance
     */
    node: TNode;
    /**
     * The input port values of the Node
     */
    inputs: Record<string, any>;
    /**
     * The latest state of the Node
     */
    state: Record<string, any>;
    /**
     * The global state of variables
     */
    store: Record<string, any>;
    /**
     * Methods to control the Node
     */
    controller: Controller;
}
/**
 *
 * Values passed in the Port's onFetch callback
 *
 * @example
 * ```tsx
 * export const ports = [
 *      port.output().type('string').onFetch(({ node }) => {
 *          return `I am ${node.id}`;
 *      })
 * ];
 * ```
 * @ES6FunctionArgs
 */
export interface onFetchProps {
    /**
     * The Node instance
     */
    node: TNode;
    /**
     * The input port values of the Node
     */
    inputs: Record<string, any>;
    /**
     * The latest state of the Node
     */
    state: Record<string, any>;
    /**
     * The port's cached value
     */
    cache: any;
    /**
     * The global state of variables
     */
    store: Record<string, any>;
    /**
     * Set the port's cache
     *
     * @param newValue The new cached value
     * @returns
     */
    setCache: (newValue: any) => void;
}
export type Ports = VisualPort[];
